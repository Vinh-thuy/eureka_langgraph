TWIN √ó Log Listening √ó Knowledge Graph

‚∏ª

üéØ Objectif de la r√©union

Aligner TWIN et Log Listening sur une vision commune :
	‚Ä¢	Log Listening devient le fournisseur d‚Äô√©v√©nements enrichis, en s‚Äôappuyant sur le Knowledge Graph pour comprendre le contexte technique (domaine + techno).
	‚Ä¢	TWIN reste responsable du Knowledge Graph, de la topologie, des vertex et des relations.
	‚Ä¢	Les √©v√©nements enrichis sont r√©inject√©s dans le Graph, o√π ils servent √† la fois :
	‚Ä¢	aux utilisateurs humains (lecture, analyse, navigation SI),
	‚Ä¢	et aux agents (DeepAgents + sous-agents techniques) pour identifier automatiquement le bon expert pour le bon √©v√©nement.

‚∏ª

1Ô∏è‚É£ Contexte & Vision

C√¥t√© TWIN (Digital Twin IT)
	‚Ä¢	TWIN mod√©lise le SI dans TigerGraph : composants, d√©pendances, environnements, criticit√©.
	‚Ä¢	Pour analyser un incident ou un √©v√©nement, il doit savoir :
	‚Ä¢	o√π cela se produit (quel composant),
	‚Ä¢	dans quel domaine technique (web, OS, DB, r√©seau, s√©curit√©‚Ä¶),
	‚Ä¢	sur quelle techno pr√©cise (Apache, RHEL, F5, Postgres‚Ä¶),
	‚Ä¢	quel type de sympt√¥me (4xx/5xx, timeout, OOM, port bloqu√©‚Ä¶).

C√¥t√© Log Listening
	‚Ä¢	Log Listening collecte les logs bruts via la stack Elastic + agents.
	‚Ä¢	Il dispose d√©j√† de briques de :
	‚Ä¢	normalisation,
	‚Ä¢	parsing,
	‚Ä¢	ML / d√©tection de patterns.
	‚Ä¢	Il est positionn√© id√©alement pour transformer des logs bruts en √©v√©nements enrichis.

üëâ L‚Äôenjeu : que Log Listening et TWIN se compl√®tent au lieu de dupliquer les efforts.

‚∏ª

2Ô∏è‚É£ R√¥le de Log Listening (mis √† jour avec le KG)

Log Listening devient le ‚ÄúEvent Enrichment Provider‚Äù du Digital Twin.

2.1. Consommer le Knowledge Graph pour comprendre le contexte

Pour chaque √©v√©nement :
	‚Ä¢	Log Listening utilise des identifiants techniques (hostname, service, CIID, etc.) pour interroger le Knowledge Graph.
	‚Ä¢	Le Graph renvoie le composant concern√© et ses attributs, par exemple :
	‚Ä¢	domain : ex. web, os, db, network, security
	‚Ä¢	tech_type : ex. apache, rhel, f5, postgres, paloalto
	‚Ä¢	role : ex. frontend, backend, api_gateway, proxy‚Ä¶

Ces deux notions sont fondamentales :
	‚Ä¢	domain ‚Üí aligne avec le niveau DeepAgent de domaine (Web, OS, DB, R√©seau‚Ä¶).
	‚Ä¢	tech_type ‚Üí aligne avec les sous-agents techniques experts (ApacheAgent, RedHatAgent, FirewallAgent‚Ä¶).

2.2. Produire un √©v√©nement enrichi structur√©

√Ä partir des logs + du contexte KG, Log Listening enrichit l‚Äô√©v√©nement avec :
	‚Ä¢	tech_type (niveau expert technique)
	‚Ä¢	domain (niveau agent de domaine)
	‚Ä¢	symptom_class (type d‚Äôincident : errors_4xx_5xx, timeout, oom, port_blocked‚Ä¶)
	‚Ä¢	component_id / hostname / service_name
	‚Ä¢	env (PROD / PREPROD / DEV)
	‚Ä¢	severity (P0 / P1 / P2‚Ä¶)
	‚Ä¢	source_system (elastic, dynatrace, etc.)
	‚Ä¢	confidence (score ML sur la classification)
	‚Ä¢	raw_message, raw_fields (trace brute)

2.3. Exposer ces √©v√©nements enrichis
	‚Ä¢	Log Listening expose ces events dans un alias Elastic unique, par exemple :
twin-events-enriched-v1
	‚Ä¢	La gestion interne (1 ou plusieurs index physiques) reste transparente pour TWIN.

üëâ Log Listening n‚Äô√©crit pas dans TigerGraph, mais s‚Äôappuie sur TigerGraph pour enrichir les √©v√©nements.

‚∏ª

3Ô∏è‚É£ R√¥le de TWIN

TWIN reste responsable du jumeau num√©rique et de toute la logique d‚Äôanalyse :

3.1. Ingestion
	‚Ä¢	Pipelines Airflow / Graflo lisent l‚Äôalias twin-events-enriched-v1.
	‚Ä¢	Chaque document JSON contient d√©j√† :
	‚Ä¢	domain, tech_type, symptom_class, component_id, etc.

3.2. Mapping vers le Knowledge Graph

Pour chaque √©v√©nement enrichi :
	‚Ä¢	TWIN mappe component_id / hostname / service_name vers le bon vertex Component dans TigerGraph.
	‚Ä¢	Cr√©e un vertex Event.
	‚Ä¢	Cr√©e la relation (:Event)-[:OCCURS_ON]->(:Component).

Les attributs domain, tech_type, symptom_class, env, etc. sont stock√©s dans le Graph :
	‚Ä¢	soit sur le vertex Event,
	‚Ä¢	soit en partie remont√©s / recopi√©s sur le Component (si pertinents).

3.3. Orchestration agentique

√Ä partir du Graph + de ces attributs enrichis :
	‚Ä¢	Le DeepAgent Global identifie :
	‚Ä¢	les domaines impliqu√©s (domain),
	‚Ä¢	les composants et leur contexte,
	‚Ä¢	les sous-agents techniques pertinents (tech_type + capabilities des agents).
	‚Ä¢	Les DeepAgents de domaine (Web, OS, DB, R√©seau‚Ä¶) :
	‚Ä¢	appliquent leur m√©thode d‚Äôanalyse standardis√©e,
	‚Ä¢	construisent leur plan de diagnostic (Todo list),
	‚Ä¢	orchestrent les sous-agents techniques (ApacheAgent, RedHatAgent, etc.).
	‚Ä¢	Les sous-agents techniques :
	‚Ä¢	exploitent leur RAG technique (documentation + incidents pass√©s),
	‚Ä¢	produisent des diagnostics d√©taill√©s et des actions.

‚∏ª

4Ô∏è‚É£ Contrat d‚Äôinterface ‚Äì Index Elastic

Un contrat logique unique :
	‚Ä¢	Alias : twin-events-enriched-v1

Champs cl√©s :
	‚Ä¢	@timestamp
	‚Ä¢	event_id
	‚Ä¢	source_system
	‚Ä¢	env
	‚Ä¢	component_id
	‚Ä¢	hostname
	‚Ä¢	service_name
	‚Ä¢	tech_type (apache, rhel, postgres, f5‚Ä¶)
	‚Ä¢	domain (web, os, db, network, security‚Ä¶)
	‚Ä¢	role (frontend, backend, proxy‚Ä¶)
	‚Ä¢	symptom_class (errors_4xx_5xx, timeout, oom‚Ä¶)
	‚Ä¢	severity
	‚Ä¢	confidence
	‚Ä¢	raw_message
	‚Ä¢	raw_fields

‚∏ª

5Ô∏è‚É£ Valeur ajout√©e des indicateurs domain & tech_type dans le Knowledge Graph

L‚Äôenrichissement domain / tech_type ne sert pas uniquement au routage agentique.
Une fois stock√©s dans le Knowledge Graph, ces attributs deviennent une force pour deux publics :

5.1. Pour les utilisateurs humains (lecteurs du Graph / outils de visualisation)
	‚Ä¢	Ils peuvent facilement :
	‚Ä¢	filtrer les composants et √©v√©nements par domaine (ex. ‚Äútous les incidents web en PROD‚Äù),
	‚Ä¢	filtrer par techno (ex. ‚Äútous les incidents sur Apache / RHEL / F5‚Äù),
	‚Ä¢	comprendre visuellement o√π se concentrent les probl√®mes (par domaine, par techno, par environnement).
	‚Ä¢	Les vues Graph deviennent :
	‚Ä¢	plus lisibles,
	‚Ä¢	plus p√©dagogiques,
	‚Ä¢	plus utiles pour les √©quipes Ops, SRE, architectes, s√©curit√©.

5.2. Pour les agents (DeepAgents & sous-agents techniques)
	‚Ä¢	domain ‚Üí permet aux agents d‚Äôidentifier le bon DeepAgent de domaine √† activer (Web, OS, DB, R√©seau‚Ä¶).
	‚Ä¢	tech_type ‚Üí permet de s√©lectionner le bon expert technique (ApacheAgent, RedHatAgent, FirewallAgent, etc.).
	‚Ä¢	Ces attributs deviennent des features explicites pour :
	‚Ä¢	le matching dynamique,
	‚Ä¢	le scoring agents ‚Üî √©v√©nements,
	‚Ä¢	la priorisation des actions.

üëâ En r√©sum√© :
Les indicateurs domain et tech_type, issus de l‚Äôenrichissement par Log Listening et stock√©s dans le Graph, font le lien entre :
	‚Ä¢	la compr√©hension humaine du SI (lecture du Graph),
	‚Ä¢	et la compr√©hension ‚Äúmachine‚Äù (agents qui choisissent automatiquement le bon expert pour le bon √©v√©nement).

‚∏ª

6Ô∏è‚É£ Le cercle vertueux
	1.	Log Listening consomme le Knowledge Graph pour contextualiser l‚Äô√©v√©nement ‚Üí fournit domain, tech_type, symptom_class, etc.
	2.	TWIN ing√®re cet √©v√©nement enrichi et le rattache au bon composant dans TigerGraph.
	3.	DeepAgent Global + DeepAgents de domaine utilisent ces attributs pour orchestrer les bons sous-agents techniques.
	4.	Les diagnostics et actions issus de TWIN peuvent, √† terme, √™tre r√©utilis√©s pour am√©liorer les mod√®les et les r√®gles de Log Listening.

üéØ R√©sultat : un pipeline auto-am√©liorant, coh√©rent, et align√© sur la topologie r√©elle du SI.

‚∏ª

7Ô∏è‚É£ Phrase d‚Äôouverture pour ton meeting

¬´ L‚Äôid√©e cl√©, c‚Äôest que Log Listening devient le fournisseur d‚Äô√©v√©nements enrichis, en s‚Äôappuyant sur notre Knowledge Graph pour tagger chaque √©v√©nement avec le bon domaine et la bonne techno. TWIN utilise ensuite ces √©v√©nements enrichis pour les rattacher √† la topologie, activer automatiquement les bons agents experts, et alimenter √† son tour le Graph. On cr√©e ainsi un cercle vertueux entre logs, graph et intelligence. ¬ª
